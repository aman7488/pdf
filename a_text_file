just a random text file for my use....


import React, { useState, useEffect, useMemo } from "react";
import {
  Typography,
  Grid,
  TextField,
  Card,
  CardContent,
  CircularProgress,
  Popover,
  Box,
  Button,
  FormControl,
  InputLabel,
  Select,
  Checkbox,
  ListItemText,
  OutlinedInput,
  MenuItem,
  Divider
} from "@mui/material";
import { loadExcelData } from "./services/ExcelDataService";
import { LocalizationProvider } from "@mui/x-date-pickers/LocalizationProvider";
import { AdapterDayjs } from "@mui/x-date-pickers/AdapterDayjs";
import { DatePicker } from "@mui/x-date-pickers/DatePicker";
import EntityBarChart from "../charts/EntityBarChart";
import dayjs from "dayjs";
import isSameOrAfter from "dayjs/plugin/isSameOrAfter";
import isSameOrBefore from "dayjs/plugin/isSameOrBefore";
import VolumeChart from "../charts/VolumeChart";
import ClientVolumeGrid from "../charts/ClientVolumeGrid";
import DownloadIcon from "@mui/icons-material/FileDownload";
import * as XLSX from "xlsx";

dayjs.extend(isSameOrAfter);
dayjs.extend(isSameOrBefore);

const dropdownFields = [
  "Value Date",
  "Parent ID",
  "Client Segment",
  "Group ID",
  "SETTL_METH",
  "Transaction Date",
  "P_SETTL_MEANS",
  "R_SETTL_MEANS",
  "Entity",
  "Client Label",
  "Client Long Name",
  "Client FMID",
  "SCI LEID",
  "Client Tier",
  "Client Country",
];

const ITEM_HEIGHT = 48;
const ITEM_PADDING_TOP = 8;
const MenuProps = {
  PaperProps: {
    style: {
      maxHeight: ITEM_HEIGHT * 4.5 + ITEM_PADDING_TOP,
      width: 250,
    },
  },
};

function AppContainer() {
  const [originalDropdownOptions, setOriginalDropdownOptions] = useState({});
  const [dynamicDropdownOptions, setDynamicDropdownOptions] = useState({});
  const [rawData, setRawData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [filterValues, setFilterValues] = useState({});
  const [valueDateRange, setValueDateRange] = useState({ start: null, end: null });
  const [anchorEl, setAnchorEl] = useState(null);

  useEffect(() => {
    const initialFilterValues = {};
    dropdownFields.forEach(field => {
      if (field === "Value Date") {
        initialFilterValues[field] = { start: null, end: null };
      } else {
        initialFilterValues[field] = [];
      }
    });
    setFilterValues(initialFilterValues);

    const fetchData = async () => {
      try {
        const filePath = "/data/dummy_dashboard_data.xlsx";
        const { options, jsonData } = await loadExcelData(filePath, dropdownFields);
        setOriginalDropdownOptions(options);
        setDynamicDropdownOptions(options);
        setRawData(jsonData);

        const populatedFilterValues = {};
        dropdownFields.forEach(field => {
          if (field === "Value Date") {
            populatedFilterValues[field] = { start: null, end: null };
          } else {
            // populatedFilterValues[field] = [];
            populatedFilterValues[field] = options[field]?.map(option => option.value) || [];
          }
        });
        setFilterValues(populatedFilterValues);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const getFilteredData = (data, filters, valueRange) => {
    return data.filter(row => {
      const valueDate = row["Value Date"];
      if (valueDate) {
        const rowDate = dayjs(valueDate);
        const start = valueRange.start;
        const end = valueRange.end;

        if ((start && !rowDate.isSameOrAfter(dayjs(start), 'day')) ||
          (end && !rowDate.isSameOrBefore(dayjs(end), 'day'))) {
          return false;
        }
      }

      for (const field of dropdownFields) {
        if (field === "Value Date") continue;

        if (!filters[field] || filters[field].length === 0) {
          return false;
        }

        if (filters[field] && filters[field].length > 0) {
          const rowValue = row[field];

          if ((rowValue === null || rowValue === undefined || rowValue === "") &&
            filters[field].includes("null")) {
            continue;
          }

          if (rowValue === null || rowValue === undefined || rowValue === "") {
            return false;
          }

          if (!filters[field].includes(rowValue.toString())) {
            return false;
          }
        }
      }

      return true;
    });
  };

  // Use memoized filtered data to avoid recalculating on every render
  const filteredData = useMemo(() => {
    return getFilteredData(rawData, filterValues, valueDateRange);
  }, [rawData, filterValues, valueDateRange]);

  // Update dynamic dropdown options based on currently filtered data
  useEffect(() => {
    if (!loading && originalDropdownOptions && Object.keys(originalDropdownOptions).length > 0) {
      const updatedOptions = {};

      dropdownFields.forEach(field => {
        if (field === "Value Date") {
          updatedOptions[field] = originalDropdownOptions[field];
          return;
        }

        const tempFilters = { ...filterValues };
        // delete tempFilters[field];
        tempFilters[field] = originalDropdownOptions[field]?.map(opt => opt.value) || [];

        const relevantData = getFilteredData(rawData, tempFilters, valueDateRange);

        const uniqueValues = new Set();
        relevantData.forEach(row => {
          const value = row[field];
          if (value !== null && value !== undefined && value !== "") {
            uniqueValues.add(value.toString());
          }
        });

        const fieldOptions = Array.from(uniqueValues).map(value => ({
          value: value,
          label: value
        }));

        const hasNullOption = originalDropdownOptions[field]?.some(opt => opt.value === "null");
        if (hasNullOption) {
          fieldOptions.push({ value: "null", label: "(NULL)" });
        }

        updatedOptions[field] = fieldOptions;
      });

      setDynamicDropdownOptions(updatedOptions);
    }
  }, [filterValues, valueDateRange, rawData, originalDropdownOptions, loading]);

  const handleFilterChange = (field, value) => {
    if (field === "Value Date") {
      setFilterValues(prev => ({
        ...prev,
        [field]: value
      }));
      return;
    }

    if (value.includes("__all__")) {
      const allValues = dynamicDropdownOptions[field]?.map(option => option.value) || [];

      if (filterValues[field]?.length > 0) {
        setFilterValues(prev => ({
          ...prev,
          [field]: []
        }));
      }
      else {
        setFilterValues(prev => ({
          ...prev,
          [field]: allValues
        }));
      }
    }
    else {
      setFilterValues(prev => ({
        ...prev,
        [field]: value
      }));
    }
  };

  const handleDownload = () => {
    const worksheet = XLSX.utils.json_to_sheet(filteredData);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, "Sheet1");
    XLSX.writeFile(workbook, "DVP_Trade_Volumes.xlsx");
  };

  if (loading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '200px' }}>
        <CircularProgress size={30} />
        <Typography sx={{ ml: 2 }}>Loading data...</Typography>
      </div>
    );
  }

  if (error) {
    return <Typography color="error">{error}</Typography>;
  }

  return (
    <LocalizationProvider dateAdapter={AdapterDayjs}>
      <>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
          <Typography
            variant="h4"
            sx={{ mb: 4, ml: 2, fontWeight: "bold", color: "#1976d2", textAlign: "center" }}
          >
            Delivery Versus Payment (DVP) Trade Volumes
          </Typography>

          <Button
            variant="contained"
            color="primary"
            onClick={handleDownload}
            sx={{ minWidth: 0, padding: 1 }}
            title="Download filtered data"
          >
            <DownloadIcon />
          </Button>
        </Box>

        <Card elevation={3} sx={{ p: 2 }}>
          <CardContent sx={{ padding: "16px !important" }}>
            <Grid container spacing={2}>
              {dropdownFields.map((field, index) => {
                if (field === "Value Date") {
                  return (
                    <Grid item xs={12} sm={6} md={4} lg={3} key={index}>
                      <TextField
                        label="Value Date"
                        value={
                          valueDateRange.start && valueDateRange.end
                            ? `${dayjs(valueDateRange.start).format("YYYY-MM-DD")} to ${dayjs(valueDateRange.end).format("YYYY-MM-DD")}`
                            : ""
                        }
                        onClick={(e) => setAnchorEl(e.currentTarget)}
                        InputProps={{ readOnly: true }}
                        fullWidth
                        variant="outlined"
                        size="small"
                        sx={{ maxWidth: "200px", minWidth: "150px" }}
                      />
                      <Popover
                        open={Boolean(anchorEl)}
                        anchorEl={anchorEl}
                        onClose={() => setAnchorEl(null)}
                        anchorOrigin={{
                          vertical: 'bottom',
                          horizontal: 'left',
                        }}
                      >
                        <Box p={2} display="flex" gap={2}>
                          <DatePicker
                            label="Start Date"
                            value={valueDateRange.start}
                            onChange={(newValue) => {
                              const updated = { ...valueDateRange, start: newValue };
                              setValueDateRange(updated);
                              handleFilterChange("Value Date", updated);
                            }}
                          />
                          <DatePicker
                            label="End Date"
                            value={valueDateRange.end}
                            onChange={(newValue) => {
                              const updated = { ...valueDateRange, end: newValue };
                              setValueDateRange(updated);
                              handleFilterChange("Value Date", updated);
                            }}
                          />
                        </Box>
                      </Popover>
                    </Grid>
                  );
                }

                return (
                  <Grid item xs={12} sm={6} md={4} lg={3} key={index}>
                    <FormControl fullWidth variant="outlined" size="small" sx={{ minWidth: "200px" }}>
                      <InputLabel id={`${field}-label`}>{field}</InputLabel>
                      <Select
                        labelId={`${field}-label`}
                        id={`${field}-select`}
                        multiple
                        value={filterValues[field] || []}
                        onChange={(e) => handleFilterChange(field, e.target.value)}
                        input={<OutlinedInput label={field} />}
                        renderValue={(selected) => {
                          if (selected.length === 0) {
                            return 'All';
                          }
                          if (selected.length > 2) {
                            return `${selected.length} selected`;
                          }
                          return selected.join(', ');
                        }}
                        MenuProps={MenuProps}
                      >
                        <MenuItem value="__all__" sx={{ fontWeight: 'bold' }}>
                          <Checkbox
                            checked={dynamicDropdownOptions[field] && filterValues[field]?.length === dynamicDropdownOptions[field].length}
                            indeterminate={filterValues[field]?.length > 0 &&
                              filterValues[field]?.length < dynamicDropdownOptions[field]?.length}
                          />
                          <ListItemText primary="(All)" />
                        </MenuItem>
                        <Divider />
                        {dynamicDropdownOptions[field]?.map((option) => (
                          <MenuItem key={option.value} value={option.value}>
                            <Checkbox checked={filterValues[field]?.indexOf(option.value) > -1} />
                            <ListItemText primary={option.label} />
                          </MenuItem>
                        ))}
                      </Select>
                    </FormControl>
                  </Grid>
                );
              })}
            </Grid>
          </CardContent>
        </Card>

        <Card elevation={3} sx={{ mt: 4, p: 2 }}>
          <CardContent>
            <EntityBarChart data={filteredData} />
          </CardContent>
        </Card>

        <Card elevation={3} sx={{ mt: 4, p: 2 }}>
          <CardContent>
            <VolumeChart data={filteredData} />
          </CardContent>
        </Card>

        <Card elevation={3} sx={{ mt: 4, p: 2 }}>
          <CardContent>
            <ClientVolumeGrid data={filteredData} />
          </CardContent>
        </Card>
      </>
    </LocalizationProvider>
  );
}

export default AppContainer;

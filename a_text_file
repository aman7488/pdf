import React, { useState, useEffect, useRef } from "react";
import {
  Container,
  Typography,
  Button,
  Box,
  Alert,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Divider,
  TextField,
  Tooltip,
  CircularProgress,
  Chip,
} from "@mui/material";
import { DataGrid } from "@mui/x-data-grid";
import * as XLSX from "xlsx";
import DownloadIcon from "@mui/icons-material/Download";
import CheckIcon from "@mui/icons-material/Check";
import ClearIcon from "@mui/icons-material/Clear";
import StorageIcon from "@mui/icons-material/Storage";
import SchemaIcon from "@mui/icons-material/Schema";
import AbcIcon from "@mui/icons-material/Abc";
import PlayArrowIcon from "@mui/icons-material/PlayArrow";
import InfoIcon from "@mui/icons-material/Info";
import { ExpandMore } from "@mui/icons-material";
import SimpleCodeEditor from "react-simple-code-editor";
import Prism from "prismjs";
import "prismjs/components/prism-sql";
import "prismjs/themes/prism.css";
import { useAuth } from "./AuthContext";
import axios from "axios";
import { SqlApiService } from "../services/sqlApiService";

const EnhancedSelfService = () => {
  const [query, setQuery] = useState("");
  const [rows, setRows] = useState([]);
  const [columns, setColumns] = useState([]);
  const [error, setError] = useState("");
  const [success, setSuccess] = useState("");
  const [loading, setLoading] = useState(false);
  const [queryStats, setQueryStats] = useState(null);
  const [searchTerm, setSearchTerm] = useState("");
  const [expandedDBs, setExpandedDBs] = useState(new Set());
  const [expandedSchemas, setExpandedSchemas] = useState(new Set());
  const [dbStructure, setDbStructure] = useState([
    {
      name: "SCI",
      schemas: [
        {
          name: "P52LESUBPROFILE",
          tableColumns: [],
        },
        {
          name: "P119LMPREGULATORYINFO",
          tableColumns: [],
        },
      ],
    },
    {
      name: "CDU_LAKE",
      schemas: [
        {
          name: "audit_document_details_storage_uat",
          tableColumns: [],
        },
        {
          name: "termsheets_storage",
          tableColumns: [],
        },
      ],
    },
  ]);
  const editorRef = useRef(null);
  const textareaRef = useRef(null);

  const ellipsisText = {
    maxWidth: "140px",
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    display: "inline-block",
  };

  useEffect(() => {
    const fetchColumns = async () => {
      const updatedStructure = await Promise.all(
        dbStructure.map(async (db) => {
          const updatedSchema = await Promise.all(
            db.schemas.map(async (schema) => {
              try {
                const url = `https://dqslcdpuat.uk.standardchartered.com/dqsl/query/status?table=${db.name}.${schema.name}&showFields=true`;
                const response = await axios.get(url);

                const fields = response?.data[0].columns || [];

                return {
                  ...schema,
                  tableColumns: fields,
                };
              } catch (err) {
                console.log("Failed to fetch columns");
                return {
                  ...schema,
                  tableColumns: [],
                };
              }
            })
          );
          return {
            ...db,
            schemas: updatedSchema,
          };
        })
      );
      setDbStructure(updatedStructure);
    };
    fetchColumns();
  }, []);

  const getSchemaKey = (dbIndex, schemaIndex) => `${dbIndex}-${schemaIndex}`;
  const { logout } = useAuth();

  const handleToggleDB = (dbIndex) => {
    setExpandedDBs((prev) => {
      const newSet = new Set(prev);
      newSet.has(dbIndex) ? newSet.delete(dbIndex) : newSet.add(dbIndex);
      return newSet;
    });
  };

  const handleToggleSchema = (dbIndex, schemaIndex) => {
    const key = getSchemaKey(dbIndex, schemaIndex);
    setExpandedSchemas((prev) => {
      const newSet = new Set(prev);
      newSet.has(key) ? newSet.delete(key) : newSet.add(key);
      return newSet;
    });
  };

  const handleLogout = async () => {
    try {
      await logout();
    } catch (error) {
      setError(error.message);
    }
  };

  useEffect(() => {
    if (!searchTerm) {
      setExpandedDBs(new Set());
      setExpandedSchemas(new Set());
      return;
    }

    const dbs = new Set();
    const schemas = new Set();

    dbStructure.forEach((db, dbIndex) => {
      const dbMatch = db.name.toLowerCase().includes(searchTerm.toLowerCase());

      db.schemas.forEach((schema, schemaIndex) => {
        const schemaMatch = schema.name
          .toLowerCase()
          .includes(searchTerm.toLowerCase());
        const tableMatch = schema.tableColumns?.some((table) =>
          table.toLowerCase().includes(searchTerm.toLowerCase())
        );

        if (schemaMatch || tableMatch) {
          schemas.add(getSchemaKey(dbIndex, schemaIndex));
        }
      });

      if (
        dbMatch ||
        [...schemas].some((key) => key.startsWith(`${dbIndex}-`))
      ) {
        dbs.add(dbIndex);
      }
    });

    setExpandedDBs(dbs);
    setExpandedSchemas(schemas);
  }, [searchTerm, dbStructure]);

  const handleSubmit = async () => {
    try {
      setError("");
      setSuccess("");
      setLoading(true);
      setQueryStats(null);

      // Validate query
      const validation = SqlApiService.validateQuery(query);
      if (!validation.isValid) {
        setError(validation.error);
        return;
      }

      const startTime = Date.now();

      // Execute query via API
      const result = await SqlApiService.executeQuery(query);

      const endTime = Date.now();
      const executionTime = endTime - startTime;

      if (result.success) {
        // Limit display to 100 rows
        const displayRows = result.data.slice(0, 100);
        const totalRows = result.data.length;
        const isLimited = totalRows > 100;
        
        setRows(displayRows);
        setColumns(result.columns);
        setQueryStats({
          rowCount: totalRows,
          displayedRows: displayRows.length,
          columnCount: result.columns.length,
          executionTime: executionTime,
          isLimited: isLimited,
        });
        
        if (isLimited) {
          setSuccess(`Query executed successfully! Displaying ${displayRows.length} of ${totalRows} rows in ${executionTime}ms`);
        } else {
          setSuccess(`Query executed successfully! Retrieved ${totalRows} rows in ${executionTime}ms`);
        }
      } else {
        setError(result.error);
        setRows([]);
        setColumns([]);
      }
    } catch (err) {
      console.error("Query execution error:", err);
      setError("An unexpected error occurred while executing the query.");
      setRows([]);
      setColumns([]);
    } finally {
      setLoading(false);
    }
  };

  const handleClear = () => {
    setQuery("");
    setRows([]);
    setColumns([]);
    setError("");
    setSuccess("");
    setQueryStats(null);
  };

  const handleDownloadCSV = () => {
    try {
      if (!rows.length && !queryStats?.rowCount) {
        setError("No data available to download.");
        return;
      }

      // For CSV download, we need to use the original full dataset, not just displayed rows
      // Since we only store displayed rows, we'll need to re-fetch or store full data
      // For now, let's use the displayed data but show a note if limited
      const csvData = rows.map((row) => {
        const rowData = {};
        columns.forEach((col) => {
          rowData[col.headerName] = row[col.field];
        });
        return rowData;
      });

      const worksheet = XLSX.utils.json_to_sheet(csvData);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, "Query_Results");
      
      // Generate filename with timestamp
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
      const filename = `query_results_${timestamp}.csv`;
      
      XLSX.writeFile(workbook, filename);
      
      if (queryStats?.isLimited) {
        setSuccess(`Downloaded ${rows.length} displayed rows as ${filename}. Note: This contains only the first 100 rows shown in the table.`);
      } else {
        setSuccess(`Data exported successfully as ${filename}`);
      }
    } catch (err) {
      console.error("Download Failed:", err);
      setError("Something went wrong while downloading the file.");
    }
  };

  useEffect(() => {
    if (editorRef.current) {
      textareaRef.current = editorRef.current.querySelector("textarea");
    }
  }, []);

  const insertAtQuery = (insertText) => {
    if (!editorRef.current) return;

    const textArea = textareaRef.current;
    const start = textArea.selectionStart;
    const end = textArea.selectionEnd;

    const newQuery =
      query.substring(0, start) + insertText + query.substring(end);

    setQuery(newQuery);

    requestAnimationFrame(() => {
      textArea.focus();
      textArea.selectionStart = textArea.selectionEnd =
        start + insertText.length;
    });
  };

  return (
    <Container
      maxWidth={false}
      sx={{ width: "100vw", height: "100vh", paddingTop: 4 }}
    >
      <Box sx={{ display: "flex", height: "100%" }}>
        {/* Database Explorer Panel */}
        <Box
          sx={{
            width: "20%",
            pr: 2,
            borderRight: "1px solid #ccc",
            overflowY: "auto",
            height: "100vh",
          }}
        >
          <Typography
            variant="h6"
            sx={{ color: "#2e86c1", fontWeight: "bold", mb: 2 }}
          >
            Databases
          </Typography>

          <TextField
            fullWidth
            variant="outlined"
            size="small"
            placeholder="Search DB, Schema, Table..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            sx={{ mb: 2 }}
          />

          {dbStructure?.map((db, dbIndex) => {
            const isDBExpanded = expandedDBs.has(dbIndex);

            return (
              <Accordion
                key={dbIndex}
                expanded={isDBExpanded}
                onChange={() => handleToggleDB(dbIndex)}
              >
                <AccordionSummary expandIcon={<ExpandMore />}>
                  <Box sx={{ display: "flex", gap: 2 }}>
                    <SchemaIcon sx={{ color: "#8e44ad" }} />
                    <Typography
                      draggable
                      onDragStart={(e) =>
                        e.dataTransfer.setData("text/plain", db.name)
                      }
                      onDoubleClick={() => insertAtQuery(db.name)}
                      sx={{ fontWeight: "bold", cursor: "grab" }}
                    >
                      {db.name}
                    </Typography>
                  </Box>
                </AccordionSummary>

                <AccordionDetails>
                  {db?.schemas?.map((schema, schemaIndex) => {
                    const schemaKey = getSchemaKey(dbIndex, schemaIndex);
                    const isSchemaExpanded = expandedSchemas.has(schemaKey);

                    return (
                      <Accordion
                        key={schemaKey}
                        expanded={isSchemaExpanded}
                        onChange={() =>
                          handleToggleSchema(dbIndex, schemaIndex)
                        }
                        sx={{ ml: 2 }}
                      >
                        <AccordionSummary expandIcon={<ExpandMore />}>
                          <Box sx={{ display: "flex", gap: 2 }}>
                            <StorageIcon sx={{ color: "#27ae60" }} />
                            <Tooltip title={schema.name}>
                              <Typography
                                draggable
                                onDragStart={(e) =>
                                  e.dataTransfer.setData(
                                    "text/plain",
                                    `${db.name}.${schema.name}`
                                  )
                                }
                                onDoubleClick={() =>
                                  insertAtQuery(`${db.name}.${schema.name}`)
                                }
                                sx={{ cursor: "grab", ...ellipsisText }}
                              >
                                {schema.name}
                              </Typography>
                            </Tooltip>
                          </Box>
                        </AccordionSummary>

                        <AccordionDetails>
                          {schema?.tableColumns?.map((table, tableIndex) => (
                            <Box key={tableIndex}>
                              <Box
                                sx={{
                                  display: "flex",
                                  alignItems: "center",
                                  gap: 2,
                                }}
                              >
                                <AbcIcon sx={{ color: "#2e86c1" }} />
                                <Tooltip title={table}>
                                  <Typography
                                    draggable
                                    onDragStart={(e) =>
                                      e.dataTransfer.setData(
                                        "text/plain",
                                        `${db.name}.${schema.name}.${table}`
                                      )
                                    }
                                    onDoubleClick={() =>
                                      insertAtQuery(
                                        `${db.name}.${schema.name}.${table}`
                                      )
                                    }
                                    sx={{
                                      ml: 2,
                                      py: 0.5,
                                      cursor: "grab",
                                      ...ellipsisText,
                                    }}
                                  >
                                    {table}
                                  </Typography>
                                </Tooltip>
                              </Box>
                            </Box>
                          ))}
                        </AccordionDetails>
                      </Accordion>
                    );
                  })}
                </AccordionDetails>
              </Accordion>
            );
          })}
        </Box>

        {/* Main Content Panel */}
        <Box
          sx={{ width: "80%", pl: 2, display: "flex", flexDirection: "column" }}
        >
          {/* Header */}
          <Box
            sx={{
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              mb: 2,
            }}
          >
            <Typography
              variant="h4"
              sx={{ color: "#2e86c1", fontWeight: "bold" }}
            >
              FM-MIS Self Service (Enhanced)
            </Typography>
            <Box sx={{ display: "flex", gap: 1 }}>
              <Button
                variant="contained"
                onClick={handleLogout}
                sx={{ bgcolor: "red" }}
              >
                Logout
              </Button>
              <Button 
                variant="contained" 
                onClick={handleDownloadCSV}
                disabled={!rows.length}
              >
                <DownloadIcon />
              </Button>
            </Box>
          </Box>

          {/* Query Editor Section */}
          <Box
            sx={{
              display: "flex",
              gap: 2,
              mb: 2,
              boxShadow: 8,
              padding: "30px",
              borderRadius: 1,
            }}
          >
            <Box sx={{ width: "100%" }}>
              <Box sx={{ display: "flex", justifyContent: "space-between", alignItems: "center", mb: 1 }}>
                <Typography
                  variant="subtitle1"
                  sx={{ fontWeight: "bold" }}
                >
                  Enter SQL Query
                </Typography>
                {queryStats && (
                  <Box sx={{ display: "flex", gap: 1 }}>
                    <Chip 
                      icon={<InfoIcon />} 
                      label={queryStats.isLimited ? `${queryStats.displayedRows}/${queryStats.rowCount} rows` : `${queryStats.rowCount} rows`}
                      size="small" 
                      color={queryStats.isLimited ? "warning" : "primary"}
                    />
                    <Chip 
                      icon={<InfoIcon />} 
                      label={`${queryStats.columnCount} columns`} 
                      size="small" 
                      color="secondary" 
                    />
                    <Chip 
                      icon={<InfoIcon />} 
                      label={`${queryStats.executionTime}ms`} 
                      size="small" 
                      color="success" 
                    />
                  </Box>
                )}
              </Box>
              <div ref={editorRef}>
                <SimpleCodeEditor
                  value={query}
                  onValueChange={(code) => setQuery(code)}
                  highlight={(code) =>
                    Prism.highlight(code, Prism.languages.sql, "sql")
                  }
                  padding={16}
                  placeholder="Enter SQL query (e.g., SELECT * FROM CDU_LAKE.audit_document_details_storage_uat LIMIT 10;)"
                  style={{
                    fontFamily: "monospace",
                    fontSize: 16,
                    border: "1px solid #ccc",
                    borderRadius: 4,
                    backgroundColor: "#f9f9f9",
                    minHeight: "150px",
                    width: "auto",
                    whiteSpace: "pre-wrap",
                  }}
                  onDrop={(e) => {
                    try {
                      e.preventDefault();
                      const droppedText = e.dataTransfer.getData("text/plain");
                      if (!droppedText) {
                        throw new Error("Invalid data dropped");
                      }
                      setQuery((prev) => prev + " " + droppedText);
                    } catch (err) {
                      console.error("Drop Error:", err);
                      setError("Failed to add dropped text to query");
                    }
                  }}
                  onDragOver={(e) => e.preventDefault()}
                />
              </div>
            </Box>
            <Box
              sx={{
                display: "flex",
                flexDirection: "column",
                gap: 2,
                justifyContent: "center",
                alignItems: "center",
              }}
            >
              <Button
                variant="contained"
                sx={{ bgcolor: "#27ae60", height: "40px", minWidth: "120px" }}
                onClick={handleSubmit}
                disabled={loading || !query.trim()}
                startIcon={loading ? <CircularProgress size={20} /> : <PlayArrowIcon />}
              >
                {loading ? "Running..." : "Execute"}
              </Button>
              <Button
                variant="contained"
                sx={{ bgcolor: "#e74c3c", height: "40px", minWidth: "120px" }}
                onClick={handleClear}
                disabled={loading}
                startIcon={<ClearIcon />}
              >
                Clear
              </Button>
            </Box>
          </Box>

          {/* Status Messages */}
          {error && (
            <Alert severity="error" sx={{ mb: 2 }}>
              {error}
            </Alert>
          )}

          {success && (
            <Alert severity="success" sx={{ mb: 2 }}>
              {success}
            </Alert>
          )}

          {queryStats && queryStats.isLimited && (
            <Alert severity="info" sx={{ mb: 2 }}>
              Displaying only 100 rows out of {queryStats.rowCount} total rows. Download the CSV to get the complete dataset.
            </Alert>
          )}

          {/* Results Section */}
          <Box sx={{ boxShadow: 8, padding: "30px", flex: 1, minHeight: 0 }}>
            <Typography variant="h6" sx={{ mb: 2, fontWeight: "bold" }}>
              Query Results:
            </Typography>
            <Box sx={{ height: "100%", minHeight: "400px" }}>
              <DataGrid
                rows={rows}
                columns={columns}
                pageSize={25}
                rowsPerPageOptions={[10, 25, 50, 100]}
                checkboxSelection
                disableSelectionOnClick
                loading={loading}
                filterMode="client"
                sx={{
                  "& .MuiDataGrid-columnHeaders": {
                    fontWeight: "bold",
                    backgroundColor: "#f5f5f5",
                  },
                  "& .MuiDataGrid-columnHeaderTitle": {
                    fontWeight: "bold",
                  },
                  "& .MuiDataGrid-footerContainer": {
                    fontWeight: "bold",
                  },
                  height: "100%",
                }}
                localeText={{
                  noRowsLabel: loading ? "Executing query..." : "No data to display. Execute a query to see results.",
                }}
              />
            </Box>
          </Box>
        </Box>
      </Box>
    </Container>
  );
};

export default EnhancedSelfService;
